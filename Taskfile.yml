# Global Taskfile for AI-powered Git automation
# Managed by workbench repo: https://github.com/otto-nation/otto-workbench
# Installed location: ~/.config/task/Taskfile.yml
#
# To customize per-project: Create a local Taskfile.yml in your project
# To edit global config: Edit ~/.config/task/taskfile.env

version: "3"

tasks:
  # ============================================================================
  # GIT AUTOMATION
  # ============================================================================
  setup-ai:
    desc: "Setup AI configuration"
    silent: true
    cmds:
      - |
        CONFIG_DIR="$HOME/.config/task"
        ENV_FILE="$CONFIG_DIR/taskfile.env"

        mkdir -p "$CONFIG_DIR"

        if [ ! -f "$ENV_FILE" ]; then
          echo "# Taskfile AI Configuration" > "$ENV_FILE"
          echo "# Uncomment and configure one of the examples below or add your own" >> "$ENV_FILE"
          echo "" >> "$ENV_FILE"
          echo "# AI_COMMAND=claude -p --agent ci-cd --strict-mcp-config" >> "$ENV_FILE"
          echo "# AI_COMMAND=kiro-cli chat --no-interactive --agent ci-cd" >> "$ENV_FILE"
          echo "# AI_COMMAND=copilot --agent ci-cd -p" >> "$ENV_FILE"
          echo "" >> "$ENV_FILE"
          printf "  ✓ Created %s\n" "$ENV_FILE"
          echo "→ Edit to configure your AI command"
        else
          printf "→ %s already exists\n" "$ENV_FILE"
          if ! grep -q "AI_COMMAND=claude" "$ENV_FILE"; then
            printf "  Add Claude example? [Y/n] "
            read -r REPLY
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
              echo "" >> "$ENV_FILE"
              echo "# AI_COMMAND=claude -p --agent ci-cd --strict-mcp-config" >> "$ENV_FILE"
              printf "  ✓ Added Claude example\n"
            fi
          fi
        fi

  check-ai:
    internal: true
    silent: true
    cmds:
      - |
        LOCAL_ENV=".taskfile/taskfile.env"
        GLOBAL_ENV="$HOME/.config/task/taskfile.env"

        if [ -f "$LOCAL_ENV" ]; then
          ENV_FILE="$LOCAL_ENV"
        elif [ -f "$GLOBAL_ENV" ]; then
          ENV_FILE="$GLOBAL_ENV"
        else
          echo "✗ AI not configured. Run: task setup-ai"
          exit 1
        fi

        if grep -q "^AI_COMMAND=" "$ENV_FILE"; then
          AI_CMD=$(grep "^AI_COMMAND=" "$ENV_FILE" | cut -d'=' -f2- | cut -d' ' -f1)
          if command -v "$AI_CMD" >/dev/null 2>&1; then
            mkdir -p /tmp/task-ai
            grep "^AI_COMMAND=" "$ENV_FILE" | cut -d'=' -f2- > /tmp/task-ai/command
          else
            printf "✗ AI command not found: %s\n" "$AI_CMD"
            exit 1
          fi
        else
          printf "✗ AI_COMMAND not set in %s\n" "$ENV_FILE"
          exit 1
        fi

  commit:
    desc: "Generate AI-powered commit message based on staged changes"
    silent: true
    dir: '{{.USER_WORKING_DIR | default .TASKFILE_DIR}}'
    deps: [check-ai]
    cmds:
      - |
        . "{{.TASKFILE_DIR}}/lib/ai-commit.sh"

        STAGED_FILES=$(git diff --cached --name-only)
        if [ -z "$STAGED_FILES" ]; then
          echo "✗ No staged changes found. Use 'git add' first."
          exit 1
        fi

        echo "→ Analyzing staged changes with AI..."
        echo ""

        DIFF_CONTENT=$(git diff --cached --no-color)
        FILE_LIST=$(echo "$STAGED_FILES" | tr '\n' ', ' | sed 's/,$//')
        AI_COMMAND=$(cat /tmp/task-ai/command)

        find_commitlint_config
        build_commit_rules
        generate_commit_msg "$DIFF_CONTENT" "$FILE_LIST"

        echo "✓ AI analysis complete"
        echo ""
        echo "→ Generated commit message:"
        echo "   $AI_MSG"
        echo ""

        validate_commit_msg "$AI_MSG" || exit 1

        echo "→ Committing..."
        git commit -m "$AI_MSG"
        echo "✓ Committed successfully"

  reword:
    desc: "Reword a commit message with AI (default: HEAD; or: task reword -- SHA)"
    silent: true
    dir: '{{.USER_WORKING_DIR | default .TASKFILE_DIR}}'
    deps: [check-ai]
    cmds:
      - |
        # CLI_ARGS contains everything after "--"; strip whitespace so empty args become HEAD
        RAW_ARG="{{.CLI_ARGS}}"
        COMMIT_SHA="${RAW_ARG// /}"
        COMMIT_SHA="${COMMIT_SHA:-HEAD}"

        # Resolve to full SHA; catch invalid refs before doing anything else
        TARGET_SHA=$(git rev-parse "$COMMIT_SHA" 2>/dev/null) || {
          echo "✗ Invalid commit: $COMMIT_SHA"
          exit 1
        }

        # Auto-stash tracked changes so rebase has a clean working tree
        STASHED=false
        if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
          echo "→ Stashing uncommitted changes..."
          git stash push -m "task-reword-stash"
          STASHED=true
        fi

        TMPFILE=$(mktemp)
        EDITOR_SCRIPT=$(mktemp)
        SEQ_EDITOR=$(mktemp)

        # Always pop stash and remove temp files on exit, even if something fails
        cleanup() {
          rm -f "$TMPFILE" "$EDITOR_SCRIPT" "$SEQ_EDITOR" 2>/dev/null || true
          if [ "$STASHED" = true ]; then
            echo "→ Restoring stashed changes..."
            git stash pop || true
          fi
        }
        trap cleanup EXIT

        . "{{.TASKFILE_DIR}}/lib/ai-commit.sh"

        echo "→ Analyzing commit with AI..."
        FULL_DIFF=$(git show "$TARGET_SHA" --no-color)
        AI_COMMAND=$(cat /tmp/task-ai/command)

        find_commitlint_config
        build_commit_rules
        generate_commit_msg "$FULL_DIFF"

        echo "✓ AI analysis complete"
        echo ""
        echo "→ Generated commit message:"
        echo "   $AI_MSG"
        echo ""

        validate_commit_msg "$AI_MSG" || exit 1

        HEAD_SHA=$(git rev-parse HEAD)

        if [ "$TARGET_SHA" = "$HEAD_SHA" ]; then
          # HEAD is a simple amend — no rebase needed
          echo "→ Amending HEAD commit..."
          NO_VERIFY=1 git commit --amend --no-verify -m "$AI_MSG"
          echo "✓ Commit amended"
        else
          echo "→ Rewording via rebase (history will be rewritten from this commit forward)..."

          # GIT_EDITOR: injects our generated message into git's commit message buffer
          echo "$AI_MSG" > "$TMPFILE"
          printf '#!/bin/bash\ncp "%s" "$1"\n' "$TMPFILE" > "$EDITOR_SCRIPT"
          chmod +x "$EDITOR_SCRIPT"

          # GIT_SEQUENCE_EDITOR: marks only the target commit as reword; all others stay as pick
          SHORT_SHA=$(git rev-parse --short "$TARGET_SHA")
          printf '#!/bin/bash\nsed "s/^pick %s /reword %s /" "$1" > "$1.tmp" && mv "$1.tmp" "$1"\n' \
            "$SHORT_SHA" "$SHORT_SHA" > "$SEQ_EDITOR"
          chmod +x "$SEQ_EDITOR"

          # core.hooksPath=/dev/null disables all git hooks during rebase; NO_VERIFY=1 for hook scripts that check the env var
          NO_VERIFY=1 GIT_SEQUENCE_EDITOR="$SEQ_EDITOR" GIT_EDITOR="$EDITOR_SCRIPT" \
            git -c core.hooksPath=/dev/null rebase -i "${TARGET_SHA}^"

          echo "✓ Commit reworded"

          # History was rewritten — warn if the branch is already published
          CURRENT_BRANCH=$(git branch --show-current)
          if git ls-remote --heads origin "$CURRENT_BRANCH" 2>/dev/null | grep -q .; then
            echo ""
            echo "⚠  History rewritten — force push required: git push --force-with-lease"
          fi
        fi

  pr-content:
    desc: "Generate AI-powered PR content (internal helper)"
    internal: true
    silent: true
    dir: '{{.USER_WORKING_DIR | default .TASKFILE_DIR}}'
    deps: [check-ai]
    cmds:
      - |
        BRANCH=$(git branch --show-current)
        if [ "$BRANCH" = "main" ]; then
          echo "✗ Cannot create PR from main branch"
          exit 1
        fi

        # Extract issue number from branch name (e.g., feature/ISSUE-123-description)
        ISSUE_NUMBER=$(echo "$BRANCH" | grep -oE '[A-Z]+-[0-9]+' | head -1)

        # If no issue in branch name, prompt for it
        if [ -z "$ISSUE_NUMBER" ]; then
          echo "→ No issue number found in branch name: $BRANCH"
          echo ""
          read -p "Enter issue number (e.g., ISSUE-123) or press Enter to skip: " USER_ISSUE
          ISSUE_NUMBER="$USER_ISSUE"
        else
          echo "✓ Found issue number: $ISSUE_NUMBER"
        fi

        COMMITS=$(git log --oneline origin/main..HEAD)
        COMMIT_COUNT=$(git rev-list --count origin/main..$BRANCH)
        CHANGED_FILES=$(git diff --name-only origin/main..$BRANCH)

        # Use PR template if exists, otherwise use simple format
        HAS_TEMPLATE=false
        if [ -f .github/pull_request_template.md ]; then
          PR_TEMPLATE=$(cat .github/pull_request_template.md)
          HAS_TEMPLATE=true
        else
          PR_TEMPLATE="## Summary

          ## Changes

          ## Testing"
          # Remove leading whitespace from each line
          PR_TEMPLATE=$(echo "$PR_TEMPLATE" | sed 's/^[[:space:]]*//')
        fi

        AI_PROMPT="Generate a professional PR title and fill out this template based on the changes:

        Template:
        $PR_TEMPLATE

        Branch: $BRANCH
        Issue: ${ISSUE_NUMBER:-None}
        Commits: $COMMIT_COUNT

        Recent commits:
        $COMMITS

        Changed files:
        $CHANGED_FILES

        Return: TITLE: <title>
        DESCRIPTION: <filled template>"

        AI_COMMAND=$(cat /tmp/task-ai/command)

        RAW_RESPONSE=$(echo "$AI_PROMPT" | $AI_COMMAND)
        AI_RESPONSE=$(echo "$RAW_RESPONSE" | sed 's/\x1b\[[0-9;]*[a-zA-Z]//g' | sed 's/\x1b\[[0-9;]*R//g' | tr -d '\033\007\015' | sed 's/^[> ]*//g')

        PR_TITLE=$(echo "$AI_RESPONSE" | grep "^TITLE:" | sed 's/^TITLE: //' | head -1 | tr -d '\n\r' | sed 's/^`//;s/`$//')
        PR_DESCRIPTION=$(echo "$AI_RESPONSE" | sed -n '/^DESCRIPTION:/,$ p' | sed '1d' | sed 's/^```markdown$//' | sed 's/^```$//')

        if [ -z "$PR_TITLE" ]; then PR_TITLE="feat: improve codebase"; fi
        if [ -z "$PR_DESCRIPTION" ]; then PR_DESCRIPTION="## Summary\n\nBranch: $BRANCH\nCommits: $COMMIT_COUNT"; fi

        # Only add "Closes" if no PR template and user confirms (GitHub issues only)
        if [ "$HAS_TEMPLATE" = "false" ] && [ -n "$ISSUE_NUMBER" ]; then
          # Check if it's a GitHub issue (numeric with optional #)
          CLEAN_ISSUE=$(echo "$ISSUE_NUMBER" | sed 's/^#//')
          if echo "$CLEAN_ISSUE" | grep -qE '^[0-9]+$'; then
            # It's a GitHub issue
            echo ""
            read -p "Close issue #$CLEAN_ISSUE when PR merges? (y/N): " CLOSE_ISSUE
            if [ "$CLOSE_ISSUE" = "y" ] || [ "$CLOSE_ISSUE" = "Y" ]; then
              PR_DESCRIPTION="Closes #$CLEAN_ISSUE\n\n$PR_DESCRIPTION"
            fi
          fi
        fi

        mkdir -p /tmp/task-pr
        echo "$PR_TITLE" > /tmp/task-pr/title
        echo "$PR_DESCRIPTION" > /tmp/task-pr/description

        echo "Title: $PR_TITLE"
        echo "Description:"
        echo "$PR_DESCRIPTION"

  create-pr:
    desc: "Create AI-powered pull request with smart title and description"
    silent: true
    dir: '{{.USER_WORKING_DIR | default .TASKFILE_DIR}}'
    cmds:
      - |
        BRANCH=$(git branch --show-current)

        # Check if remote branch exists
        if git ls-remote --heads origin $BRANCH | grep -q $BRANCH; then
          # Remote exists, check for divergence
          git fetch origin $BRANCH --quiet

          LOCAL=$(git rev-parse @)
          REMOTE=$(git rev-parse @{u})
          BASE=$(git merge-base @ @{u})

          if [ "$LOCAL" = "$REMOTE" ]; then
            echo "✓ Branch is up to date with remote"
          elif [ "$LOCAL" = "$BASE" ]; then
            echo "! Remote has commits not in local branch"
            echo "✗ Cannot create PR - please pull first: git pull"
            exit 1
          elif [ "$REMOTE" = "$BASE" ]; then
            echo "→ Local has unpushed commits, pushing..."
            if ! git push origin $BRANCH; then
              echo "✗ Push failed"
              exit 1
            fi
          else
            echo "✗ Branch has diverged from remote"
            echo "→ Fix with: git pull --rebase or git reset"
            exit 1
          fi
        else
          # Remote doesn't exist, push it
          echo "→ Pushing new branch to remote..."
          if ! git push -u origin $BRANCH; then
            echo "✗ Push failed"
            exit 1
          fi
        fi

        echo "→ Analyzing changes with AI: $BRANCH"
      - task: pr-content
      - |
        PR_TITLE=$(cat /tmp/task-pr/title)
        PR_DESCRIPTION=$(cat /tmp/task-pr/description)
        BRANCH=$(git branch --show-current)

        echo "✓ AI analysis complete"
        echo "→ Creating PR..."

        # Detect cross-fork scenario (origin is a fork of a parent repo) and fail early
        # with a clear message rather than letting gh produce a cryptic GraphQL error
        PARENT_REPO=$(gh repo view --json parent -q '.parent.nameWithOwner' 2>/dev/null || true)

        if [ -n "$PARENT_REPO" ]; then
          ORIGIN_URL=$(git remote get-url origin)
          echo "✗ Cross-fork PR detected — update your remote to point directly to the target repo"
          echo "  origin: $ORIGIN_URL"
          echo "  target: $(gh repo view "$PARENT_REPO" --json url -q '.url' 2>/dev/null || echo "$PARENT_REPO")"
          exit 1
        fi

        PR_OUTPUT=$(gh pr create --title "$PR_TITLE" --body "$PR_DESCRIPTION" --assignee @me 2>&1) || true

        PR_URL=$(echo "$PR_OUTPUT" | grep -o 'https://github[^[:space:]]*' || true)

        if [ -n "$PR_URL" ]; then
          echo "✓ Pull request created"
          echo "$PR_URL"
        else
          echo "✗ PR creation failed"
          echo "$PR_OUTPUT"
          exit 1
        fi

  update-pr:
    desc: "Update current PR description with AI-generated content"
    silent: true
    dir: '{{.USER_WORKING_DIR | default .TASKFILE_DIR}}'
    cmds:
      - |
        BRANCH=$(git branch --show-current)
        if [ "$BRANCH" = "main" ]; then
          echo "✗ Cannot update PR from main branch"
          exit 1
        fi

        echo "→ Checking for existing PR..."
        PR_NUMBER=$(gh pr view --json number -q .number 2>/dev/null)

        if [ -z "$PR_NUMBER" ]; then
          echo "✗ No PR found for branch: $BRANCH"
          echo "→ Use 'task create-pr' to create a new PR"
          exit 1
        fi

        echo "→ Analyzing changes with AI: $BRANCH"
      - task: pr-content
      - |
        PR_DESCRIPTION=$(cat /tmp/task-pr/description)
        PR_NUMBER=$(gh pr view --json number -q .number 2>/dev/null)

        echo "✓ AI analysis complete"
        echo "→ Updating PR #$PR_NUMBER..."

        gh pr edit $PR_NUMBER --body "$PR_DESCRIPTION"

        echo "✓ PR description updated"
        echo "→ View: $(gh pr view --json url -q .url)"

  # ============================================================================
  # UTILITY
  # ============================================================================

  help:
    desc: "Show this help message"
    silent: true
    cmds:
      - |
        TASKFILE_PATH="${TASKFILE}"
        IS_GLOBAL=false

        if [[ "$TASKFILE_PATH" == *".config/task/Taskfile.yml"* ]]; then
          IS_GLOBAL=true
        fi

        echo "workbench  task runner"
        echo ""

        if [ "$IS_GLOBAL" = true ]; then
          echo "Using global Taskfile"
          echo "   Location: ~/.config/task/Taskfile.yml"
          echo "   Managed by: https://github.com/otto-nation/otto-workbench"
          echo ""
        fi

        echo "AI-Powered Git Automation:"
        echo "   setup-ai       Setup AI configuration (first-time setup)"
        echo "   commit         AI-generated commit messages"
        echo "   reword         AI reword of a commit (default: HEAD; or: task reword -- SHA)"
        echo "   create-pr      AI-generated PR (auto-pushes if needed)"
        echo "   update-pr      Update existing PR description"
        echo ""
        echo "For all tasks: task --list"
