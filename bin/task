#!/usr/bin/env bash
# Task wrapper — falls back to the global Taskfile when no local one exists.
# Installed to ~/.local/bin/task, which takes precedence over the real task binary.
# This wrapper detects whether a local Taskfile exists; if not, it injects the global
# one via --taskfile so task commands work from any directory without per-project setup.
#
# Usage: task [command] [args...]
#   - Uses ./Taskfile.yml or ./Taskfile.yaml if present in the current directory
#   - Falls back to ~/.config/task/Taskfile.yml

set -euo pipefail

_SELF="$(readlink "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
. "$(dirname "$_SELF")/../lib/ui.sh"

GLOBAL_TASKFILE="$HOME/.config/task/Taskfile.yml"

# Find the real task binary by temporarily removing ~/.local/bin from PATH — without this,
# `which task` would find this wrapper script and exec would recurse infinitely.
# || true prevents set -e from aborting; an empty TASK_BIN is handled explicitly below.
TASK_BIN=$(PATH=$(echo "$PATH" | tr ':' '\n' | grep -v "^$HOME/.local/bin$" | tr '\n' ':') which task 2>/dev/null || true)

if [ -z "$TASK_BIN" ]; then
  err "task binary not found in PATH"
  exit 1
fi

# Check if local Taskfile exists
if [ -f "Taskfile.yml" ] || [ -f "Taskfile.yaml" ]; then
  # Use local Taskfile
  exec "$TASK_BIN" "$@"
else
  # Use global Taskfile
  if [ -f "$GLOBAL_TASKFILE" ]; then
    exec "$TASK_BIN" --taskfile "$GLOBAL_TASKFILE" "$@"
  else
    err "No local Taskfile found and global Taskfile not found at $GLOBAL_TASKFILE"
    exit 1
  fi
fi
