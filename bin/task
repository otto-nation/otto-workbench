#!/usr/bin/env bash
# Task wrapper — installed to ~/.local/bin/task, which takes precedence over the real binary.
# Handles two cases:
#   1. Local Taskfile exists → pass through to the real task binary unchanged
#   2. --global flag → strip the flag and use ~/.config/task/Taskfile.yml explicitly
#
# Usage: task [--global] [command] [args...]
#   task commit              Uses ./Taskfile.yml in the current directory
#   task --global commit     Uses ~/.config/task/Taskfile.yml from anywhere

set -euo pipefail

_SELF="$(readlink "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
. "$(dirname "$_SELF")/../lib/ui.sh"

GLOBAL_TASKFILE="$HOME/.config/task/Taskfile.yml"

# Find the real task binary by temporarily removing ~/.local/bin from PATH — without this,
# `which task` would find this wrapper script and exec would recurse infinitely.
# || true prevents set -e from aborting; an empty TASK_BIN is handled explicitly below.
TASK_BIN=$(PATH=$(echo "$PATH" | tr ':' '\n' | grep -v "^$HOME/.local/bin$" | tr '\n' ':') which task 2>/dev/null || true)

if [ -z "$TASK_BIN" ]; then
  err "task binary not found in PATH"
  exit 1
fi

# Check for --global flag; collect remaining args without it
USE_GLOBAL=false
FILTERED_ARGS=()
for arg in "$@"; do
  if [ "$arg" = "--global" ]; then
    USE_GLOBAL=true
  else
    FILTERED_ARGS+=("$arg")
  fi
done

if [ "$USE_GLOBAL" = true ]; then
  if [ ! -f "$GLOBAL_TASKFILE" ]; then
    err "Global Taskfile not found at $GLOBAL_TASKFILE"
    err "Run: task --global setup-ai"
    exit 1
  fi
  exec "$TASK_BIN" --taskfile "$GLOBAL_TASKFILE" "${FILTERED_ARGS[@]}"
elif [ -f "Taskfile.yml" ] || [ -f "Taskfile.yaml" ]; then
  exec "$TASK_BIN" "$@"
else
  err "No local Taskfile found in current directory"
  echo "  Use --global to run global tasks: task --global <command>" >&2
  exit 1
fi
